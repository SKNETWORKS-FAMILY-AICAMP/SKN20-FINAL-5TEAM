{
  "progressiveProblems": [
    {
      "id": "P1",
      "project_title": "매출 분석 시스템",
      "scenario": "당신은 이커머스 회사의 데이터 분석가입니다. 월별 매출 리포트를 생성하는 스크립트의 버그를 수정하세요!",
      "difficulty": 2,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "데이터 슬라이싱 오류",
          "instruction": "마지막 행이 누락되는 문제를 수정하세요.",
          "bug_type": "A",
          "bug_type_name": "Off-by-one",
          "questions": {
            "text": "df.iloc[1:len(df)-1]에서 왜 마지막 행이 누락될까요?",
            "options": [
              "0부터 시작하는 인덱스 때문",
              "슬라이싱 끝은 불포함인데 len-1을 해서",
              "iloc은 열을 선택하기 때문",
              "불가능한 인덱스라서"
            ],
            "answer": 1
          },
          "buggy_code": "import pandas as pd\n\ndef load_data(path):\n    df = pd.read_csv(path)\n    # 버그: 마지막 행 누락\n    data = df.iloc[1:len(df)-1]\n    return data",
          "correct_code": "import pandas as pd\n\ndef load_data(path):\n    df = pd.read_csv(path)\n    data = df.iloc[1:len(df)]\n    return data",
          "hint": "Python 슬라이싱 [start:end]는 end-1까지만 포함합니다.",
          "solution_check": {
            "type": "notContains",
            "value": "len(df)-1"
          },
          "coaching": "경계값 처리는 항상 주의해야 합니다."
        },
        {
          "step": 2,
          "title": "할인금액 Null Guard",
          "instruction": "할인율이 None인 경우 0으로 처리하세요.",
          "bug_type": "B",
          "bug_type_name": "Null Guard",
          "questions": {
            "text": "데이터에 None이 포함되어 있을 때 가장 안전한 처리 방법은?",
            "options": [
              "에러를 무시한다",
              "pd.notna()로 체크 후 기본값 할당",
              "해당 행을 삭제한다",
              "None을 문자열로 바꾼다"
            ],
            "answer": 1
          },
          "buggy_code": "def calc_rev(df):\n    for i, row in df.iterrows():\n        # 버그: row['disc']가 None일 수 있음\n        rev = row['price'] * (1 - row['disc'])",
          "correct_code": "def calc_rev(df):\n    for i, row in df.iterrows():\n        disc = row['disc'] if pd.notna(row['disc']) else 0\n        rev = row['price'] * (1 - disc)",
          "hint": "pd.notna()를 사용해보세요.",
          "solution_check": {
            "type": "contains",
            "value": "notna"
          },
          "coaching": "Defensive Programming은 필수입니다."
        },
        {
          "step": 3,
          "title": "집계 상태 누수",
          "instruction": "전역 변수 사용을 피하고 함수 내부에서 결과를 초기화하세요.",
          "bug_type": "C",
          "bug_type_name": "State Leak",
          "questions": {
            "text": "결과가 누적되는 현상을 막으려면 어떻게 해야 할까요?",
            "options": [
              "글로벌 변수를 사용한다",
              "함수 호출 시마다 내부에서 변환 객체를 새로 만든다",
              "파일로 저장한다",
              "메모리를 초기화한다"
            ],
            "answer": 1
          },
          "buggy_code": "cache = {}\ndef aggregate(df):\n    # 버그: 전역 cache 사용\n    global cache\n    for m in df['month'].unique():\n        cache[m] = df[df['month']==m]['rev'].sum()\n    return cache",
          "correct_code": "def aggregate(df):\n    cache = {}\n    for m in df['month'].unique():\n        cache[m] = df[df['month']==m]['rev'].sum()\n    return cache",
          "hint": "함수 내부에서 cache = {}를 선언하세요.",
          "solution_check": {
            "type": "notContains",
            "value": "global cache"
          },
          "coaching": "상태 관리는 함수 내부에서 독립적으로 이루어져야 합니다."
        }
      ]
    },
    {
      "id": "P2",
      "project_title": "고객 데이터 파이프라인",
      "scenario": "고객 세그먼트 분류 로직의 버그를 해결하세요.",
      "difficulty": 3,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "인덱스 접근 오류",
          "instruction": "마지막 요소 접근 시 .iloc[-1]을 사용하세요.",
          "bug_type": "A",
          "questions": {
            "text": "리스트나 데이터프레임의 끝에 접근할 때 가장 편한 인덱스는?",
            "options": [
              "0",
              "1",
              "-1",
              "len()"
            ],
            "answer": 2
          },
          "buggy_code": "def get_last(df):\n    # 버그: 복잡한 인덱스 계산\n    return df.iloc[len(df)-1-1]",
          "correct_code": "def get_last(df):\n    return df.iloc[-1]",
          "hint": "-1 인덱스를 사용하세요.",
          "solution_check": {
            "type": "contains",
            "value": "iloc[-1]"
          },
          "coaching": "Pythonic한 코드는 가독성을 높입니다."
        },
        {
          "step": 2,
          "title": "누락된 데이터 처리",
          "instruction": "결측치를 0으로 채우는 Guard 로직을 추가하세요.",
          "bug_type": "B",
          "questions": {
            "text": "NaN 값을 0으로 바꾸는 가장 간단한 pandas 메서드는?",
            "options": [
              "fillna(0)",
              "replace(0)",
              "zero()",
              "none()"
            ],
            "answer": 0
          },
          "buggy_code": "def clean(df):\n    # 버그: NaN 처리 없음\n    return df['val'].sum()",
          "correct_code": "def clean(df):\n    return df['val'].fillna(0).sum()",
          "hint": "fillna()를 사용해보세요.",
          "solution_check": {
            "type": "contains",
            "value": "fillna"
          },
          "coaching": "데이터 정제는 분석의 시작입니다."
        },
        {
          "step": 3,
          "title": "공유 객체 오염",
          "instruction": "가변 기본 인자 버그를 수정하세요.",
          "bug_type": "C",
          "questions": {
            "text": "def func(a=[]) 처럼 쓰면 안 되는 이유는?",
            "options": [
              "리스트가 너무 커서",
              "모든 함수 호출이 동일한 리스트 객체를 공유해서",
              "문법 에러라서",
              "속도가 느려서"
            ],
            "answer": 1
          },
          "buggy_code": "def process(data, results=[]):\n    results.append(data)\n    return results",
          "correct_code": "def process(data, results=None):\n    if results is None: results = []\n    results.append(data)\n    return results",
          "hint": "None을 기본값으로 사용하세요.",
          "solution_check": {
            "type": "contains",
            "value": "results=None"
          },
          "coaching": "Mutable Default Argument는 주의해야 합니다."
        }
      ]
    },
    {
      "id": "P3",
      "project_title": "재고 부족 탐지 시스템",
      "scenario": "창고 재고 모니터링 시스템의 알람 버그를 수정하세요.",
      "difficulty": 2,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "날짜 범위 오차",
          "instruction": "오늘을 포함하도록 기간 계산을 수정하세요.",
          "bug_type": "A",
          "questions": {
            "text": "7일간의 데이터를 조회할 때 6일 전부터 오늘까지인가요?",
            "options": [
              "예",
              "아니오"
            ],
            "answer": 0
          },
          "buggy_code": "def get_7days(today):\n    # 버그: 6일치만 계산됨\n    start = today - timedelta(days=7)\n    return start",
          "correct_code": "def get_7days(today):\n    start = today - timedelta(days=6)\n    return start",
          "hint": "오늘(1일) + 이전(6일) = 7일입니다.",
          "solution_check": {
            "type": "contains",
            "value": "days=6"
          },
          "coaching": "오프 바이 원 에러는 날짜 계산에서 흔합니다."
        },
        {
          "step": 2,
          "title": "기본 임계값 누락",
          "instruction": "설정이 없을 때 사용할 기본값을 지정하세요.",
          "bug_type": "B",
          "questions": {
            "text": "설정값이 없을 때 시스템 중단을 막는 전략은?",
            "options": [
              "에러 발생",
              "기본값(Fallback) 사용",
              "재시도",
              "종료"
            ],
            "answer": 1
          },
          "buggy_code": "def get_limit(product_id):\n    # 버그: 없으면 KeyError\n    return config[product_id]",
          "correct_code": "def get_limit(product_id):\n    return config.get(product_id, 10)",
          "hint": "dict.get() 메서드를 사용하세요.",
          "solution_check": {
            "type": "contains",
            "value": "get("
          },
          "coaching": "예외 처리는 시스템의 안정성을 보장합니다."
        },
        {
          "step": 3,
          "title": "클래스 변수 누수",
          "instruction": "상태를 인스턴스마다 독립적으로 관리하세요.",
          "bug_type": "C",
          "questions": {
            "text": "모든 인스턴스가 같은 데이터를 저장하는 이유는?",
            "options": [
              "클래스 변수로 선언해서",
              "인스턴스 변수로 선언해서",
              "데이터가 같아서",
              "메모리 공유 때문"
            ],
            "answer": 0
          },
          "buggy_code": "class Monitor:\n    # 버그: 클래스 변수 공유\n    logs = []\n    def add(self, msg): self.logs.append(msg)",
          "correct_code": "class Monitor:\n    def __init__(self): self.logs = []\n    def add(self, msg): self.logs.append(msg)",
          "hint": "__init__ 메서드 내부에서 선언하세요.",
          "solution_check": {
            "type": "contains",
            "value": "self.logs = []"
          },
          "coaching": "인스턴스별 상태 격리가 중요합니다."
        }
      ]
    }
  ]
}