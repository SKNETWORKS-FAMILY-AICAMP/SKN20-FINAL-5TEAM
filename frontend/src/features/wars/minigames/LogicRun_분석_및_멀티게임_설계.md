# LogicRun 분석 및 의사코드 멀티게임 설계안

## 1. 현재 상태 분석

### 1-1. 솔로 연습모드 (CoduckWars) 구조

| 페이즈 | 이름 | 내용 |
|--------|------|------|
| 1 | DIAGNOSTIC_1 | MCQ/순서배열 2문제 → 기초 개념 확인 |
| 2 | PSEUDO_WRITE | Monaco 에디터에서 자유 의사코드 작성 (체크리스트 실시간 검증) |
| 3 | PYTHON_VISUALIZATION | AI가 Python 변환 → 코드 비교 + MCQ 이해도 확인 |
| 4 | DEEP_DIVE_DESCRIPTIVE | 랜덤 시나리오 기반 서술형 심화 문제 |
| 5 | EVALUATION | 5차원 레이더 차트 + 페르소나 + 학습 영상 추천 |

**핵심 자산:**
- 5차원 AI 평가 시스템 (설계/일관성/추상화/엣지케이스/구현)
- 실시간 체크리스트 패턴 매칭 (`격리|분리|isolation|split` 등)
- 블루프린트 복구 모드 (저성취자 학습 경로)
- 힌트 덕 시스템 (동적 맥락 힌트)

### 1-2. 현재 멀티 LogicRun.vue 문제점

| 문제 | 설명 |
|------|------|
| 하드코딩된 1개 퀘스트 | `quests[]`에 로그인 아키텍처 1개만 존재 |
| 단순 타이핑 게임 | 정답 문자열을 외워서 치는 것에 불과 |
| 학습 효과 낮음 | 왜 이렇게 작성하는지 이해 없이 입력만 함 |
| 60% 키워드 매칭 | 너무 관대해서 아무 키워드나 나열해도 정답 처리 |
| 동시 풀기 구조 | 두 플레이어가 같은 라인을 풀어서 독립성 없음 |
| 레이싱 비주얼만 존재 | 게임성이 부족 (전략/선택/긴장감 없음) |

### 1-3. SpeedArchBuilder 비교 (잘 된 멀티게임 사례)

| 요소 | SpeedArchBuilder | LogicRun (현재) |
|------|-----------------|----------------|
| 라운드 | 8라운드 (다양한 시나리오) | 1퀘스트 (12줄 반복) |
| 선택지 | 9개 컴포넌트 중 4개 선택 | 자유 텍스트 입력 |
| 전략성 | 함정 컴포넌트 회피 + 슬롯 배치 | 없음 |
| 콤보 | 연속 정답 → 콤보 보너스 | 없음 |
| 시간 보너스 | 빨리 풀수록 추가 점수 | 없음 |
| 힌트 | 라운드당 2회 제한 | 항상 보여줌 |
| 등급 | S/A/B/C | 없음 |

---

## 2. 멀티게임 방식 비교

### 방식 A: 스피드 타이핑 (현재 방식 개선)

```
[시나리오] → [힌트 표시] → [의사코드 한 줄 입력] → [정답 체크] → 반복
```

**장점:** 구현 간단, 직관적
**단점:** 학습보다 타이핑 속도 게임, 의사코드 "이해"가 아닌 "암기"

### 방식 B: 빈칸 채우기 레이스 (추천)

```
[완성된 의사코드 중 핵심 부분이 빈칸] → [선택지 4개 중 정답 고르기] → 다음 빈칸
```

**장점:**
- SpeedArchBuilder처럼 선택 기반 → 빠른 판단력 테스트
- 오답 선택지가 학습 포인트 (왜 틀렸는지 알 수 있음)
- 타이핑 속도가 아닌 이해도 경쟁
- 기존 체크리스트 패턴 활용 가능

**단점:** 선택지 생성 필요 (하지만 문제 데이터에 포함 가능)

### 방식 C: 디자인 듀얼 (AI 실시간 심사)

```
[동일 시나리오 제시] → [각자 자유 의사코드 작성 (2분)] → [AI 5차원 평가] → 점수 비교
```

**장점:** 솔로 모드의 핵심 시스템(5차원 평가) 재활용, 진짜 설계 능력 경쟁
**단점:** AI 평가 시간 45초 → 대기 시간 길어 실시간감 부족, 1라운드가 너무 김

### 방식 D: 디버그 레이스

```
[버그 있는 의사코드 표시] → [버그 위치+수정 내용 입력] → 정답 체크
```

**장점:** 코드 리뷰 능력 훈련, 재미있음
**단점:** 버그 데이터 별도 준비 필요, 구현 복잡도 높음

### 방식 E: 하이브리드 (빈칸 + 짧은 작성) ⭐ 최종 추천

```
Phase 1 (속도전): 빈칸 채우기 4~5라운드 (선택지 기반, 라운드당 15초)
Phase 2 (설계전): 짧은 시나리오 1개 → 핵심 3줄 의사코드 작성 (60초)
         → 간이 AI 평가 or 키워드 매칭으로 빠른 채점
```

**장점:**
- 전반부: 빠른 판단력으로 긴장감 유지 (SpeedArchBuilder 스타일)
- 후반부: 진짜 의사코드 작성 능력 평가 (CoduckWars 핵심)
- 두 플레이어가 같은 문제를 다르게 접근 → 결과 비교 재미
- 총 게임 시간 2~3분으로 적절

---

## 3. ⭐ 최종 추천: 하이브리드 방식 상세 설계

### 3-1. 게임 흐름

```
┌─────────────────────────────────────────────────────┐
│                    LOGIC RUN v2                       │
│                                                       │
│  [INTRO] → 방 입장 & 매칭                             │
│     │                                                 │
│     ▼                                                 │
│  [PHASE 1: SPEED FILL] 빈칸 채우기 (5라운드)           │
│     │  - 라운드당 15초                                 │
│     │  - 4지선다 선택                                  │
│     │  - 콤보 시스템                                   │
│     │  - 시간 보너스                                   │
│     ▼                                                 │
│  [PHASE 2: DESIGN SPRINT] 핵심 설계 (1라운드)          │
│     │  - 시나리오 제시                                 │
│     │  - 핵심 의사코드 3~5줄 작성 (90초)               │
│     │  - 체크리스트 기반 실시간 채점                    │
│     ▼                                                 │
│  [RESULT] 종합 결과                                    │
│     - Phase1 점수 + Phase2 점수                        │
│     - 승패 판정                                        │
└─────────────────────────────────────────────────────┘
```

### 3-2. Phase 1: SPEED FILL (빈칸 채우기)

#### 화면 구성
```
┌──────────────────────────────────────────────┐
│  [P1: 320pt]    ⏱ 12s    ROUND 3/5   [P2: 280pt] │
├──────────────────────────────────────────────┤
│                                              │
│  함수 데이터_전처리(데이터셋):                │
│    ________ 데이터셋이 비어있으면:            │
│      반환 오류("데이터_없음")                 │
│    학습, 테스트 = _________(데이터셋, 0.8)    │
│                        ↑ 이 빈칸을 채워라!    │
│                                              │
│  ┌─────────┐ ┌──────────┐                    │
│  │ A. 만약  │ │ B. 반복   │                    │
│  ├─────────┤ ├──────────┤                    │
│  │ C. 동안  │ │ D. 선택   │                    │
│  └─────────┘ └──────────┘                    │
│                                              │
│  💡 힌트: 조건 분기를 수행하는 키워드 (1/2)   │
├──────────────────────────────────────────────┤
│  [P1 ████████░░] vs [P2 ██████░░░░]         │
└──────────────────────────────────────────────┘
```

#### 라운드 데이터 구조
```javascript
{
  id: 1,
  context: '데이터 전처리 파이프라인',
  codeBlock: [
    { text: '함수 데이터_전처리(데이터셋):', type: 'fixed' },
    { text: '  ________ 데이터셋이 비어있으면:', type: 'blank', blankId: 'b1' },
    { text: '    반환 오류("데이터_없음")', type: 'fixed' },
    { text: '  학습, 테스트 = _________(데이터셋, 0.8)', type: 'blank', blankId: 'b2' },
  ],
  blanks: {
    b1: {
      answer: '만약',
      options: ['만약', '반복', '동안', '선택'],
      hint: '조건 분기를 수행하는 키워드'
    },
    b2: {
      answer: '데이터_분할',
      options: ['데이터_분할', '데이터_삭제', '데이터_복사', '데이터_정렬'],
      hint: '학습/테스트 세트로 나누는 함수'
    }
  },
  currentBlank: 'b1'  // 현재 풀어야 할 빈칸
}
```

#### 채점
```
정답: +100점
오답: +0점 (HP 감소 없음 — 속도전이므로 부담 최소화)
콤보: 연속 정답 시 n번째 콤보 → +15×n 보너스
시간 보너스: 남은 초 × 5
```

### 3-3. Phase 2: DESIGN SPRINT (핵심 설계)

#### 화면 구성
```
┌──────────────────────────────────────────────┐
│  DESIGN SPRINT        ⏱ 67s                  │
├──────────────────────────────────────────────┤
│  📋 시나리오:                                 │
│  "사용자 인증 시스템에서 비밀번호 검증 후      │
│   JWT 토큰을 발급하는 로직을 설계하라"         │
│                                              │
│  ┌─ 의사코드 에디터 ─────────────────────┐   │
│  │ > 함수 인증_처리(이메일, 비밀번호):    │   │
│  │ > |                                   │   │
│  │                                       │   │
│  └───────────────────────────────────────┘   │
│                                              │
│  체크리스트:                                  │
│  ✅ 입력 검증 포함     ⬜ 에러 처리 포함      │
│  ⬜ DB 조회 포함       ⬜ 토큰 발급 포함      │
│  ⬜ 비밀번호 검증 포함                        │
│                                              │
│              [SUBMIT]                        │
├──────────────────────────────────────────────┤
│  상대방 진행도: ██████░░░░ 3/5 체크 완료      │
└──────────────────────────────────────────────┘
```

#### 채점 (체크리스트 기반 — AI 호출 없이 빠르게)
```javascript
// 기존 CoduckWars의 체크리스트 패턴 재활용
checklist: [
  { id: 'validate', label: '입력 검증',  patterns: [/검증|확인|validate|check/i] },
  { id: 'query',    label: 'DB 조회',    patterns: [/조회|검색|query|fetch|select/i] },
  { id: 'verify',   label: '비밀번호 검증', patterns: [/비밀번호|비번|password|bcrypt|해시/i] },
  { id: 'error',    label: '에러 처리',  patterns: [/오류|에러|error|예외|exception/i] },
  { id: 'token',    label: '토큰 발급',  patterns: [/토큰|token|jwt|세션|session/i] },
]

// 점수 계산
체크 1개당 = 100점
전체 완료 보너스 = 200점
시간 보너스 = 남은 초 × 3
총 최대 = 500 + 200 + 270 = 970점
```

### 3-4. 종합 점수 & 결과 화면

```
Phase 1 (SPEED FILL):  최대 ~1,500점  (60% 비중)
Phase 2 (DESIGN SPRINT): 최대 ~970점  (40% 비중)

최종 점수 = Phase1 + Phase2
등급: S(2000+) / A(1500+) / B(1000+) / C(500+) / F(<500)
```

#### 결과 화면
```
┌──────────────────────────────────────────────┐
│              🏆 P1 승리!                      │
│                                              │
│   [P1]           VS           [P2]           │
│   1,840pt                    1,520pt          │
│                                              │
│   Speed Fill:  980           Speed Fill: 820  │
│   Design:      860           Design:    700   │
│   콤보 최대: x4              콤보 최대: x2    │
│                                              │
│   [🔄 다시하기]    [🏠 나가기]                │
└──────────────────────────────────────────────┘
```

---

## 4. 기존 코드 재활용 매핑

| 기존 자산 | 출처 | 재활용 방법 |
|-----------|------|-------------|
| 체크리스트 패턴 | `useCoduckWars.js` | Phase2 실시간 채점에 그대로 사용 |
| 퀘스트 데이터 구조 | `stages.js` | 시나리오 + 체크리스트 추출하여 라운드 데이터 생성 |
| 소켓 통신 | `useRunSocket.ts` | 그대로 사용 (emitProgress, onSync) |
| 레이싱 비주얼 | `LogicRun.vue` | 듀얼 트랙 유지 (Phase1에서 진행도 표시) |
| 콤보/시간보너스 | `SpeedArchBuilder.vue` | 동일 패턴 적용 |
| IDE 에디터 UI | `LogicRun.vue` | Phase2 의사코드 입력에 재사용 |
| 힌트 시스템 | `CoduckWars.vue` | Phase1 힌트 버튼으로 변환 (라운드당 1회) |

---

## 5. 소켓 동기화 설계

```javascript
// Phase 1: 빈칸 채우기 동기화
emitProgress(roomId, {
  phase: 'speedFill',
  round: 3,
  score: 480,
  combo: 2,
  sid: socket.id
})

// Phase 2: 설계 진행도 동기화
emitProgress(roomId, {
  phase: 'designSprint',
  checksCompleted: 3,
  totalChecks: 5,
  score: 300,
  sid: socket.id
})

// 게임 종료
emitFinish(roomId, {
  totalScore: 1840,
  phase1Score: 980,
  phase2Score: 860,
  maxCombo: 4
})
```

---

## 6. 문제 데이터 예시 (5라운드분)

### Round 1: 데이터 전처리
```
함수 데이터_전처리(원본_데이터):
  [만약] 원본_데이터가 비어있으면:
    반환 오류("데이터_없음")
  정제_데이터 = [결측값_제거](원본_데이터)
  학습, 테스트 = [데이터_분할](정제_데이터, 비율=0.8)
  반환 학습, 테스트
```

### Round 2: 모델 학습
```
함수 모델_학습(학습_데이터, 레이블):
  모델 = [초기화](결정트리, 깊이=5)
  [반복] 에포크 in 범위(100):
    예측 = 모델.예측(학습_데이터)
    손실 = [손실_계산](예측, 레이블)
    모델.가중치_갱신(손실)
  반환 모델
```

### Round 3: API 요청 처리
```
함수 API_요청_처리(요청):
  [만약] 요청.인증_토큰이 없으면:
    반환 [오류_응답](401, "인증 필요")
  사용자 = [토큰_검증](요청.인증_토큰)
  데이터 = DB_조회(사용자.아이디)
  반환 성공_응답(데이터)
```

### Round 4: 이상치 탐지
```
함수 이상치_탐지(데이터_포인트들):
  평균 = [평균_계산](데이터_포인트들)
  표준편차 = [표준편차_계산](데이터_포인트들)
  이상치_목록 = []
  [반복] 포인트 in 데이터_포인트들:
    만약 |포인트 - 평균| > 표준편차 * 3:
      이상치_목록.[추가](포인트)
  반환 이상치_목록
```

### Round 5: 캐시 전략
```
함수 캐시_조회(키):
  [만약] 캐시.존재(키):
    캐시.[만료시간_갱신](키)
    반환 캐시.가져오기(키)
  데이터 = [DB_조회](키)
  캐시.저장(키, 데이터, TTL=300)
  반환 데이터
```

---

## 7. 구현 우선순위

| 순서 | 작업 | 난이도 | 효과 |
|------|------|--------|------|
| 1 | Phase1 빈칸채우기 라운드 시스템 | 중 | 핵심 게임성 확보 |
| 2 | 콤보/시간보너스 시스템 | 하 | SpeedArchBuilder에서 복사 |
| 3 | 소켓 동기화 (점수/라운드) | 중 | 기존 useRunSocket 활용 |
| 4 | Phase2 설계 스프린트 | 중 | 체크리스트 패턴 재활용 |
| 5 | 결과 화면 통합 | 하 | 기존 UI 패턴 재사용 |
| 6 | 문제 풀 확장 (10+ 시나리오) | 하 | 데이터만 추가 |
