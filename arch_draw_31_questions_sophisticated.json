[
    {
        "title": "기본 3-Tier 웹 아키텍처",
        "description": "클라이언트의 요청을 받아 웹 서버가 처리하고, 데이터베이스에 저장하는 가장 기본적인 3계층(3-Tier) 구조를 설계하세요.",
        "required": [
            "client",
            "server",
            "db"
        ],
        "hints": [
            "클라이언트가 서버로 진입합니다.",
            "서버는 데이터베이스를 참조합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "server",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "웹 브라우저의 서버 요청 (Request)"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "서버의 데이터베이스 쿼리를 통한 조회/저장"
                }
            ]
        },
        "axis_weights": {
            "기본성": "모든 웹 서비스의 뼈대가 되는 최소 구성",
            "무결성": "단일 데이터 소스 보장"
        }
    },
    {
        "title": "로드밸런서를 통한 분산 처리",
        "description": "트래픽 폭주에 대비해 단일 로드밸런서를 통해 다수의 애플리케이션 서버로 요청을 분산시키는 구조를 설계하세요.",
        "required": [
            "client",
            "lb",
            "server",
            "db"
        ],
        "hints": [
            "클라이언트와 여러 대의 서버 사이에 로드밸런서가 위치합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "lb",
                "server",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "lb",
                    "desc": "사용자 트래픽이 로드밸런서(LB)로 진입"
                },
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "LB가 뒷단의 여러 서버 인스턴스로 부하 분산(Round Robin 등)"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "각 서버에서 중앙 공용 DB에 접근"
                }
            ]
        },
        "axis_weights": {
            "가용성": "SPOF 방지 및 트래픽 폭주 대비 분산",
            "수평확장": "서버(Scale-Out) 증설 용이"
        }
    },
    {
        "title": "정적 파일 CDN 가속화",
        "description": "대용량 이미지와 동영상을 전 세계 사용자에게 지연 없이 제공하기 위해 CDN 엣지 로케이션을 활용하는 구조를 설계하세요.",
        "required": [
            "client",
            "cdn",
            "origin",
            "server"
        ],
        "hints": [
            "클라이언트는 먼저 CDN 캐시를 조회합니다.",
            "CDN에 없을 경우 원본 저장소(Origin)를 참조합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "cdn",
                "origin"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "cdn",
                    "desc": "사용자가 물리적으로 가까운 엣지 서버(CDN)에 콘텐츠 요청"
                },
                {
                    "from": "cdn",
                    "to": "origin",
                    "desc": "캐시 미스 시 CDN이 Origin 스토리지 시스템에서 원본 Fetch"
                }
            ]
        },
        "axis_weights": {
            "성능": "CDN 캐싱을 활용한 응답 지연율(Latency) 감소",
            "효율성": "Origin 서버의 트래픽 비용 및 부하 절감"
        }
    },
    {
        "title": "인메모리 캐시를 통한 쿼리 오프로딩",
        "description": "실시간 랭킹이나 세션 데이터를 위한 인메모리 캐시(Redis 등)를 도입해 메인 DB의 조회 부하를 줄이세요.",
        "required": [
            "client",
            "server",
            "cache",
            "db"
        ],
        "hints": [
            "서버는 DB를 찌르기 전, 캐시 서버를 우선적으로 조회해야 합니다.",
            "캐시 미스 시에만 DB를 조회합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "server",
                "cache",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "API 호출 트래픽"
                },
                {
                    "from": "server",
                    "to": "cache",
                    "desc": "Look-aside 패턴으로 캐시 먼저 확인"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "캐시 미스 시 DB 원본 쿼리 실행"
                }
            ]
        },
        "axis_weights": {
            "성능": "인메모리 데이터의 빠른 I/O 속도로 인한 지연시간 개선",
            "비용효율성": "백엔드 RDBMS 처리량 감소"
        }
    },
    {
        "title": "읽기/쓰기 분리 구조 (CQRS Base)",
        "description": "조회 비율이 극단적으로 높은 게시판 서비스에서, 성능 저하를 피하고자 쓰기 전용 DB와 읽기 전용 DB(Read Replica)를 분리하세요.",
        "required": [
            "client",
            "server",
            "writedb",
            "readdb"
        ],
        "hints": [
            "서버에서 쓰기는 Write DB로, 읽기는 Read DB로 направ합니다.",
            "Write DB에서 Read DB로 데이터 복제가 일어납니다."
        ],
        "rubric_functional": {
            "required_components": [
                "server",
                "writedb",
                "readdb"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "복합 요청 (Read/Write)"
                },
                {
                    "from": "server",
                    "to": "writedb",
                    "desc": "새로운 데이터 생성/업데이트 명령 (Command)"
                },
                {
                    "from": "server",
                    "to": "readdb",
                    "desc": "데이터 단순 조회 명령 (Query)"
                },
                {
                    "from": "writedb",
                    "to": "readdb",
                    "desc": "Master에서 Slave로의 실시간 데이터 비동기 복제(Replication)"
                }
            ]
        },
        "axis_weights": {
            "성능": "읽기 요청 병목 해소를 위한 Read Replica 확장",
            "안정성": "Write DB 원본 데이터 손실에 대한 백업본 역할 기반 분리"
        }
    },
    {
        "title": "MSA 기본: API 게이트웨이 도입",
        "description": "클라이언트가 여러 마이크로서비스들의 URL을 모두 알지 못해도, 단일 진입점(API Gateway)을 통해 라우팅과 인증을 일괄 처리하게 설계하세요.",
        "required": [
            "client",
            "api",
            "auth",
            "server"
        ],
        "hints": [
            "클라이언트의 모든 요청은 우선 API Gateway를 거쳐야 합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "api",
                "auth",
                "server"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "클라이언트의 단일 접점 (Single Entry Point) 요청"
                },
                {
                    "from": "api",
                    "to": "auth",
                    "desc": "게이트웨이 레이어에서 인증/토큰 검증 수행"
                },
                {
                    "from": "api",
                    "to": "server",
                    "desc": "인증 성공 후 알맞은 뒷단 비즈니스 서버로 트래픽 라우팅"
                }
            ]
        },
        "axis_weights": {
            "유지보수성": "서비스 결합도 저하 및 진입점 일원화",
            "보안성": "인증 로직 파편화 방지를 통한 토큰 통합 검증"
        }
    },
    {
        "title": "이커머스 MSA (인증/주문/결제 분리)",
        "description": "대규모 쇼핑몰 시스템에서 인증, 주문, 결제를 독립적인 마이크로서비스로 분리하고 각각의 데이터베이스를 두어 서로 완전히 독립시키세요.",
        "required": [
            "api",
            "auth",
            "order",
            "payment",
            "db"
        ],
        "hints": [
            "게이트웨이가 트래픽을 권한, 주문, 결제 별로 나누어 분배합니다.",
            "각 서비스는 하나의 범용 DB나, 분리된 개별 DB에 접근합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "api",
                "auth",
                "order",
                "payment",
                "db"
            ],
            "required_flows": [
                {
                    "from": "api",
                    "to": "auth",
                    "desc": "게이트웨이에서 인증 서비스로 위임"
                },
                {
                    "from": "api",
                    "to": "order",
                    "desc": "게이트웨이에서 주문 서비스로 주문 요청 라우팅"
                },
                {
                    "from": "api",
                    "to": "payment",
                    "desc": "게이트웨이에서 결제 서비스로 결제 승인 요청 라우팅"
                },
                {
                    "from": "order",
                    "to": "db",
                    "desc": "주문 도메인 데이터 영속화"
                },
                {
                    "from": "payment",
                    "to": "db",
                    "desc": "결제 도메인 데이터 영속화"
                }
            ]
        },
        "axis_weights": {
            "독립성": "특정 서비스에 장애가 발생해도 타 서비스의 가용성은 보존",
            "확장성": "이벤트 피크(결제 폭주 등) 시 필요한 서비스만 개별 스케일아웃"
        }
    },
    {
        "title": "비동기 메시지 큐 (이벤트 드리븐 - 기본)",
        "description": "결제 이벤트 폭발 시 메인 데이터베이스와 사용자가 타임아웃을 겪지 않도록, 메시지 큐(Message Queue, Kafka/RabbitMQ)를 사용하여 처리 속도를 조절하세요.",
        "required": [
            "producer",
            "queue",
            "consumer",
            "db"
        ],
        "hints": [
            "웹서버(Producer)가 작업을 즉시 처리하지 않고 큐에 넣고 응답합니다.",
            "백그라운드 워커(Consumer)가 큐에서 하나씩 꺼내 DB에 넣습니다."
        ],
        "rubric_functional": {
            "required_components": [
                "producer",
                "queue",
                "consumer",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "producer",
                    "desc": "클라이언트 이벤트 촉발"
                },
                {
                    "from": "producer",
                    "to": "queue",
                    "desc": "비즈니스 서버가 이벤트를 생산(Publish) 후 지연없이 응답"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "작업자(Worker) 서버 그룹이 자신의 속도에 맞게 메시지 풀링(Pull/Push)"
                },
                {
                    "from": "consumer",
                    "to": "db",
                    "desc": "오프-메인 스레드에서 차분하게 대량 데이터 적재(Bulk Insert 등)"
                }
            ]
        },
        "axis_weights": {
            "탄력성(Resilience)": "트래픽 스파이크를 메시지 큐에 임시 보관하여 시스템 마비 방지",
            "응답성": "비동기 응답 반환으로 클라이언트가 화면 대기하는 시간 단축"
        }
    },
    {
        "title": "Pub/Sub 알림 브로드캐스트 패턴",
        "description": "하나의 핵심 비즈니스 이벤트(예: 긴급 공지 또는 방송용 결제)가 다수의 대기 중인 워커/구독자에게 동시에 뿌려지도록 하는 팬아웃(Fan-out) 구조를 구성하세요.",
        "required": [
            "server",
            "queue",
            "consumer"
        ],
        "hints": [
            "하나의 발행자(Server)가 큐에 메시지를 올리면 다수의 컨슈머(Consumer)들이 각기 다른 목적으로 알림을 수신합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "server",
                "queue",
                "consumer"
            ],
            "required_flows": [
                {
                    "from": "server",
                    "to": "queue",
                    "desc": "이벤트 발생 (Publisher)"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "다수의 구독자(Subscriber/Consumer)에게 동시 전달 (Fan-out 형태 확장 가능)"
                }
            ]
        },
        "axis_weights": {
            "확장성": "새로운 기능(새로운 알림 종류 등) 추가 시 Publisher 서버의 코드 수정 없이 Consumer만 추가하면 됨",
            "결합도 감소": "이벤트 생산과 소비의 완벽한 물리적, 논리적 분리"
        }
    },
    {
        "title": "CQRS 아키텍처 (Command and Query Segregation)",
        "description": "읽기와 쓰기의 모델이나 성능 특성이 크게 다르다고 판단하여, 아예 명령(Write)을 내리는 서비스+DB와 조회(Read) 전용 서비스+DB를 분리하고 큐로 동기화하는 구조를 설계하세요.",
        "required": [
            "writesvc",
            "readsvc",
            "writedb",
            "readdb",
            "queue"
        ],
        "hints": [
            "클라이언트에서 작성은 Write Svc로 전송됩니다.",
            "수정 이력을 큐를 통해 Read Svc에 브로드캐스트합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "writesvc",
                "readsvc",
                "writedb",
                "readdb",
                "queue"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "writesvc",
                    "desc": "상태 변경(Write) 명령 전달"
                },
                {
                    "from": "writesvc",
                    "to": "writedb",
                    "desc": "쓰기 모델 데이터베이스 트랜잭션 수행"
                },
                {
                    "from": "writesvc",
                    "to": "queue",
                    "desc": "이벤트 발행 (예: '게시물 생성됨')"
                },
                {
                    "from": "queue",
                    "to": "readsvc",
                    "desc": "조회 전용 서비스가 이벤트 수신"
                },
                {
                    "from": "readsvc",
                    "to": "readdb",
                    "desc": "비정규화 등 조회에 극도로 최적화된 형태로 읽기 DB 갱신"
                },
                {
                    "from": "client",
                    "to": "readsvc",
                    "desc": "클라이언트 조회 요청"
                }
            ]
        },
        "axis_weights": {
            "복잡성 도메인 관리": "C/U/D 트랜잭션 도메인과 뷰(View) 렌더링 도메인을 기능 레벨에서 완전분리",
            "조회율 최적화": "데이터 갱신 시 약간의 지연(Eventual Consistency) 감수 후 조회의 비용을 대폭 하락"
        }
    },
    {
        "title": "Saga Pattern (비동기 분산 트랜잭션)",
        "description": "마이크로서비스에서 여러 도메인의 상태를 변경할 때, 2PC를 사용하지 않고 개별 트랜잭션을 일련의 이벤트(Kafka 등 큐 기반)로 연결하고 보상 트랜잭션으로 커밋/롤백하는 '사가' 구조 패턴을 설계하세요.",
        "required": [
            "order",
            "payment",
            "queue",
            "db"
        ],
        "hints": [
            "주문 서비스에서 1차 DB 커밋, 성공 시 큐를 타고 결제 서비스로...",
            "결제 서비스에서도 큐를 통해 완료 이벤트를 응답"
        ],
        "rubric_functional": {
            "required_components": [
                "order",
                "payment",
                "queue",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "order",
                    "desc": "초기 주문 생성 요청 트랜잭션 발동"
                },
                {
                    "from": "order",
                    "to": "db",
                    "desc": "주문 서비스 로컬 DB 임시 상태 기록 (Status: PENDING)"
                },
                {
                    "from": "order",
                    "to": "queue",
                    "desc": "결제 요청 이벤트 발행 ('OrderCreated')"
                },
                {
                    "from": "queue",
                    "to": "payment",
                    "desc": "결제 서비스가 이벤트 확인 후 처리 프로세스 진행"
                },
                {
                    "from": "payment",
                    "to": "db",
                    "desc": "결제 서비스 로컬 DB 반영 (승인 또는 거절)"
                },
                {
                    "from": "payment",
                    "to": "queue",
                    "desc": "상태 업데이트 역발행 ('PaymentSucceeded' / 'PaymentFailed')"
                },
                {
                    "from": "queue",
                    "to": "order",
                    "desc": "주문 서비스가 결제 결과 수신 후 주문 최종 확정 또는 보상 취소 트랜잭션"
                }
            ]
        },
        "axis_weights": {
            "데이터 정합성": "데이터베이스 간의 강력한 트랜잭션 결합(분산 락) 없이 고성능으로 결과적 정합성(Eventual Consistency) 달성"
        }
    },
    {
        "title": "대용량 파일 업로드",
        "description": "클라이언트가 수 기가바이트의 영상을 서버의 메모리 부하 없이 안전하게 스토리지(S3 등)에 업로드하는 Pre-signed URL 메커니즘을 구성하세요.",
        "required": [
            "client",
            "server",
            "origin",
            "db"
        ],
        "hints": [
            "서버를 거쳐서 큰 파일을 S3에 저장하면 네트워크가 바닥납니다.",
            "클라이언트가 서버로부터 권한(서명)을 발급받아 스토리지 시스템인 'Origin'으로 직행해야 합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "server",
                "origin",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "사용자 측에서 업로드 허가 요청 메타데이터 발송"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "업로드 이력 생성 (Pending 상태)"
                },
                {
                    "from": "server",
                    "to": "client",
                    "desc": "제한된 시간만 유효한 Pre-signed 스토리지(Origin) 전송 URL 발급 응답"
                },
                {
                    "from": "client",
                    "to": "origin",
                    "desc": "거대한 파일 데이터를 서버를 우회하여 S3(Origin)로 Multi-part Direct Upload"
                },
                {
                    "from": "origin",
                    "to": "server",
                    "desc": "(옵션) 업로드 직후 트리거된 Webhook 등 백엔드 통보"
                }
            ]
        },
        "axis_weights": {
            "네트워크 병목 해소": "웹 서비스 인스턴스의 네트워크 대역폭 및 메모리 Out-Of-Memory(OOM) 방지",
            "보안": "안전한 1회성 서명 URL(Pre-signed) 기반 객체 스토리지 취약점 우회"
        }
    },
    {
        "title": "실시간 검색어 자동완성 (Search Auto-Complete)",
        "description": "사용자가 키보드를 칠 때마다 즉각적으로 검색어 추천 목록이 노출되어야 합니다. 밀리초 단위의 초고속 응답을 위해 딕셔너리 구조(Trie)가 로드된 캐시 서버를 활용하세요.",
        "required": [
            "client",
            "api",
            "server",
            "cache"
        ],
        "hints": [
            "RDBMS(관계형 DB) Like 쿼리는 느립니다. API Gateway를 통과한 즉시 서버단에서 메모리 기반 저장소인 Cache(Redis)로만 질의해야 합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "api",
                "server",
                "cache"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "타이핑(Debounce/Throttle) 순간 발생한 빠른 쿼리 요청"
                },
                {
                    "from": "api",
                    "to": "server",
                    "desc": "검색 서비스 전달"
                },
                {
                    "from": "server",
                    "to": "cache",
                    "desc": "Redis Sorted Sets나 Trie 모듈에 의존하는 키 매칭 쿼리 (Disk/DB 조회 원천 배제)"
                }
            ]
        },
        "axis_weights": {
            "초연결성": "사용자 입력 반응에 대해 Disk 접근 없이 메모리 수준의 지연시간 보장"
        }
    },
    {
        "title": "배치 파일 처리 파이프라인 (Data Lake & ETL)",
        "description": "매일 수 테라바이트 로그/CSV 파일을 집계해야 합니다. 원본(Origin)의 파일을 메시지 형태로 변환(웹/Queue) 후, 배치 컨슈머가 밤새 처리해 DB 트랜잭션을 최소한으로 사용하는 환경을 설계하세요.",
        "required": [
            "origin",
            "producer",
            "queue",
            "consumer",
            "readdb"
        ],
        "hints": [
            "스토리지 시스템(Origin)에서 이벤트가 발생하거나 읽어와 워크를 만들면...",
            "그 덩어리들을 큐에 집어넣어 다수의 Worker(Consumer)가 밤새 쪼개서 처리합니다. 결과는 분석용 DB(ReadDB)로"
        ],
        "rubric_functional": {
            "required_components": [
                "origin",
                "producer",
                "queue",
                "consumer",
                "readdb"
            ],
            "required_flows": [
                {
                    "from": "origin",
                    "to": "producer",
                    "desc": "S3(Origin) 등 객체 저장 이벤트(ObjectCreated) 감지 또는 주기적 크론 트리거로 로그 수집 배치(Producer) 기동"
                },
                {
                    "from": "producer",
                    "to": "queue",
                    "desc": "처리해야 할 파티션과 메타데이터 단위로 메시지 태스크 쪼개기"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "Spark/Hadoop/Lambda 등 분석 워커 노드 다발체(Consumer Group)가 분산 처리 수행"
                },
                {
                    "from": "consumer",
                    "to": "readdb",
                    "desc": "집계/정제된(Clean data) 분석용 웨어하우스(ReadDB) 적재"
                }
            ]
        },
        "axis_weights": {
            "처리량/처리속도": "큐를 이용한 병렬 맵리듀스(Map-Reduce)의 확장 분산 구조"
        }
    },
    {
        "title": "클릭스트림 실시간 분석 파이프라인",
        "description": "수백만 유저의 생중계된 마우스 이동, 클릭 등의 행동(행동 로그 트래픽)을 손실 없이 실시간으로 빨아들이고 저장소에 적재하세요.",
        "required": [
            "client",
            "api",
            "producer",
            "queue",
            "db"
        ],
        "hints": [
            "사용자 행동의 거대한 트래픽은 API 직후 Producer 계층이 받아 모두 Queue로 빨아들여야(Ingestion) 합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "api",
                "producer",
                "queue",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "분당 수천만 번 발사되는 Beacon 행동 이력 수집 (Single Packet)"
                },
                {
                    "from": "api",
                    "to": "producer",
                    "desc": "데이터 수집 엔드포인트 도달 (Kafka Producer/ Kinesis Agent)"
                },
                {
                    "from": "producer",
                    "to": "queue",
                    "desc": "로컬 디스크에 임시버퍼를 쓰지 않고 가장 높은 스루풋을 자랑하는 분산 큐에 고압 스트리밍"
                },
                {
                    "from": "queue",
                    "to": "db",
                    "desc": "Sink Connector/Consumer 등을 통해 HDFS, NoSQL, 엘라스틱서치(DB) 계열로 안전하게 순차 벌크 복사 적재"
                }
            ]
        },
        "axis_weights": {
            "무중단성 보장": "최전방 Producer 계층이 유저 행동 파편에 대한 응답 지연을 만들어서는 안 되며 Fire-and-Forget 수행"
        }
    },
    {
        "title": "단일 진입점 글로벌 트래픽 분산 (Global DNS 밸런싱)",
        "description": "미국과 한국 양쪽에 백엔드 리전을 두고 글로벌 비즈니스를 합니다. 사용자의 위치에 따라 가장 지연 패킷이 적은 대륙 쪽 로드밸런서로 라우팅하는 네트워크 기반 구조(Cloud Architect)를 설계하세요.",
        "required": [
            "client",
            "dns",
            "lb",
            "server"
        ],
        "hints": [
            "클라이언트가 이름 변환 시, 로케이션(DNS 계층)에 기반해 가장 가까운 로드밸런서 IP를 반환해야 합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "dns",
                "lb",
                "server"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "dns",
                    "desc": "자신이 위치한 ISP 기지국에서 도메인에 대한 지연시간 기반의 라우팅 정책(Latency Routing) 질의"
                },
                {
                    "from": "dns",
                    "to": "client",
                    "desc": "US-EAST 혹은 AP-NORTHEAST 중 가장 지연속도가 짧은 리전의 LB IP 반환"
                },
                {
                    "from": "client",
                    "to": "lb",
                    "desc": "지역 단일 로드밸런서 진입"
                },
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "해당 리전 내부 웹서비스 인스턴스로 분산 할당 도착"
                }
            ]
        },
        "axis_weights": {
            "글로벌 지연속도 관리": "다중 리전 환경에서 가장 기본적인 Geolocation 기반 네트워크 트래픽 단축기법 사용 설계"
        }
    },
    {
        "title": "액티브-액티브 완전 이중화 (Cross-Region Multi-Site)",
        "description": "한 대륙이 화재로 삭제되어도, 지구의 절반 서버가 실시간으로 계속 운영되는 궁극의 장애 대처 환경(Active-Active)을 구상하세요.",
        "required": [
            "dns",
            "lb",
            "server",
            "writedb",
            "readdb"
        ],
        "hints": [
            "DNS가 글로벌하게 양측 모두 사용 가능하도록 지원합니다.",
            "두 리전이 양방향으로 동기화를 이뤄야 합니다. (이곳에선 단방향 복제 화살표를 리전간 통신 상징으로 활용)"
        ],
        "rubric_functional": {
            "required_components": [
                "dns",
                "lb",
                "server",
                "writedb",
                "readdb"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "dns",
                    "desc": "Route53 등에서 50대 50 비율 또는 Failover-Active 상태로 멀티 가용IP 전달"
                },
                {
                    "from": "dns",
                    "to": "lb",
                    "desc": "(논리적으로 DNS가 LB 엔드포인트를 매핑함)"
                },
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "살아남은 리전의 그룹 배포 환경"
                },
                {
                    "from": "server",
                    "to": "writedb",
                    "desc": "쓰기 발생"
                },
                {
                    "from": "writedb",
                    "to": "readdb",
                    "desc": "(여기서의 readdb를 타 리전의 글로벌 복제 스토리지로 모사) 재해 발생 시를 대비한 데이터 복제 지연시간 극복 흐름"
                }
            ]
        },
        "axis_weights": {
            "고가용도 99.999%": "물리 데이터 센터 전체 재난(정전 등) 발생 시에도 서비스 지속 운영이 가능하도록 격리 조치"
        }
    },
    {
        "title": "WAF & LB (DDoS, SQLi 원천 방어)",
        "description": "해커가 대량의 가짜 봇 트래픽이나 DB 파괴를 노리는 쿼리(SQL Injection)를 전송하고 있습니다. 서버와 DB의 피해를 사전에 봉쇄하세요.",
        "required": [
            "client",
            "waf",
            "lb",
            "server",
            "db"
        ],
        "hints": [
            "LB 앞이나 뒤에 존재하며 모든 패킷의 내부 Payload를 분석(L7 필터)하는 Web Application Firewall(방화벽) 계층이 필수입니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "waf",
                "lb",
                "server"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "waf",
                    "desc": "봇넷 및 공격 스크립트 기반 악성 요청 트래픽 다량 유입"
                },
                {
                    "from": "waf",
                    "to": "lb",
                    "desc": "정적 룰셋, IP 평판(Rate Limiting), 서명 기반으로 필터된 깨끗한 요청만 후위의 로드밸런서로 전달(Ingress 차단)"
                },
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "트래픽 분산과 오토스케일 수행 처리"
                }
            ]
        },
        "axis_weights": {
            "방어 기제": "인프라 가장 앞단, 혹은 LB와 맞닿은 곳에서 악의적 Layer7 계층 공격의 텍스트 파싱을 기반으로 격리"
        }
    },
    {
        "title": "실시간 협업 웹소켓 채널 (Redis Pub/Sub 활용)",
        "description": "다수의 사용자가 실시간 웹소켓(WebSocket)으로 접속하여 채팅이나 협업 문서를 편집 중입니다. 서버 여러 대 사이의 메시지 푸시를 동기화하기 위한 이벤트 전파용 중앙 매개체 아키텍처를 설계하세요.",
        "required": [
            "client",
            "server",
            "cache"
        ],
        "hints": [
            "웹소켓 서버들은 각자 다른 클라이언트들과 물려 있습니다. 서로 대화하려면 중간 거쳐가는 공용 스폰지(Redis/PubSub 채널)가 필요합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "server",
                "cache"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "A 클라이언트가 N번 서버에 웹소켓 터널 연결 후 채팅 메시지 발송"
                },
                {
                    "from": "server",
                    "to": "cache",
                    "desc": "N번 소켓서버가 인스턴스 전역의 메시지 전파 메모리 허브(Redis 채널 Publish)에 브로드캐스트 위임"
                },
                {
                    "from": "cache",
                    "to": "server",
                    "desc": "구독 상태인 M, L, X 등 모든 소켓 서버(Subscriber)가 메세지를 수신 처리하여 즉각 풀오버"
                },
                {
                    "from": "server",
                    "to": "client",
                    "desc": "B, C 사용자 등 연결된 Socket에게 다시 하향 푸시(Push)"
                }
            ]
        },
        "axis_weights": {
            "상태 전파력": "메모리 인스턴스간 무(State-less)상태 웹소켓 통신 과정에서 Pub/Sub 패턴 응용의 최상위 적합성"
        }
    },
    {
        "title": "서버리스 마이크로서비스 (Serverless API)",
        "description": "사용자가 많을 때는 초당 1만대를 버티고, 없을 때는 인프라 유지비용을 0원으로 수렴시키기 위해(Scale to Zero) AWS Lambda 기반 함수 중심의 백엔드를 구축하세요.",
        "required": [
            "client",
            "api",
            "server",
            "db"
        ],
        "hints": [
            "이 아키텍처에선 'server' 노드를 EC2 대신 가동-소멸(Invoke)을 반복하는 FaaS(함수) 단위로 봅니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "api",
                "server",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "API 게이트웨이를 통한 HTTP 인터페이스 트리거(Trigger)"
                },
                {
                    "from": "api",
                    "to": "server",
                    "desc": "게이트웨이가 이벤트 페이로드를 조립해 Serverless 함수(Lambda) 컨테이너 인스턴스를 초단기 호출(Cold/Warm Start)"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "(옵션이지만 필수적) DB 연결을 통한 데이터 읽기/쓰기 커넥션 관리(비연결성 대비 설계)"
                }
            ]
        },
        "axis_weights": {
            "비용 이점": "서버 모니터링 관리포인트 및 유휴 자원 발생 시간 제로 달성",
            "탄력도": "트래픽이 순간 폭증해도 백엔드 프로비저닝 없이 API단에서 무제한 함수 복제 수행"
        }
    },
    {
        "title": "에지 컴퓨팅 기반 권한 보안 검증가속",
        "description": "중앙 마이크로서비스(Auth)로 날아오기 무섭게 해킹 시도가 많아 부하가 폭증할 때, 사용자 거주지에서 가장 가까운 CDN 노드(Edge) 컴퓨터 위에서 실시간으로 JWT 로그인 토큰을 차단하는 인증 오프로딩 인프라를 마련하세요.",
        "required": [
            "client",
            "cdn",
            "auth",
            "server"
        ],
        "hints": [
            "클라이언트의 요청을 거대한 CDN 망이 받아들이고, CDN 엣지 노드에 붙어있는 작은 인증 함수(Auth)가 불량(거짓) 요청을 미리 끊어냅니다. 이후 정상 트래픽만 본 서버(Server)로 향합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "cdn",
                "auth",
                "server"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "cdn",
                    "desc": "CloudFront 등 Edge 접속 시 이벤트 인터셉트"
                },
                {
                    "from": "cdn",
                    "to": "auth",
                    "desc": "Edge 노드 주변에 배포된 경량 Auth(람다 앳 엣지 등)를 통한 헤더 파싱/비대면 서명 검증 수행"
                },
                {
                    "from": "auth",
                    "to": "server",
                    "desc": "유효한 사용자 로그인 컨텍스트만 중앙 코어 서버(Server) 망으로 안전하게 도착(패스 스루)"
                }
            ]
        },
        "axis_weights": {
            "토폴로지 성능 최적화": "본 서버가 있는 Region 외부 대륙간 네트워크 망에서 방어 1단계를 거쳐 백엔드 시스템 부하 급감 및 불법 트래픽 원천 차단"
        }
    },
    {
        "title": "분산 락 (Leader Election & Distributed Lock)",
        "description": "여러 서버가 '결제 1회 취소', '이벤트 쿠폰 응모' 등 중복이 발생해선 절대로 안되는 단일 자원을 동시에 다루기 위해, 특정 인메모리 분산 키-벨류 저장소에서 락(Lock, 열쇠)을 획득하게끔 설계하세요.",
        "required": [
            "client",
            "lb",
            "server",
            "cache",
            "db"
        ],
        "hints": [
            "서버들이 경쟁적으로 Cache에 'Lock'을 잡을 수 있는지 질의하고, 획득한 1대의 서버만이 DB에 안전하게 쓰기 자격을 얻습니다."
        ],
        "rubric_functional": {
            "required_components": [
                "server",
                "cache",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "lb",
                    "desc": "동시다발적 클릭 (예찰된 부하 트래픽)"
                },
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "동시성 이슈(Concurrency Hazard)가 있는 여러 비즈니스 서버 인스턴스 레이어 도달"
                },
                {
                    "from": "server",
                    "to": "cache",
                    "desc": "Redis SETNX 오퍼레이션 등을 이용해 단독점유형 분산 락(Spin Lock/Pub-Sub) 획득 요청 및 반환 대기"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "Cache로부터 락 점유 권한을 승인받은 서버만이 격리수준을 믿어 의심치 않고 DB Update Query 커밋"
                }
            ]
        },
        "axis_weights": {
            "정합성 강제": "애플리케이션(L7) 레벨에서의 단일 스레드 격리 구조 보장성 및 데드락(Deadlock) 타임아웃 예외 설계 철학"
        }
    },
    {
        "title": "API Rate Limiting (처리량 제한/쓰로틀링)",
        "description": "악성스크레이퍼나 과도한 새로고침을 막기 위해 API 진입 시점에 초당 Rq 허용치를 넘는 경우 Cache를 활용해 즉시 차단(Http 429 Error)하는 토큰 버킷 구조를 구성하십시오.",
        "required": [
            "client",
            "api",
            "cache",
            "server"
        ],
        "hints": [
            "우선 관문(API)에서 캐시(Cache)에 질문합니다. '이 IP / 유저가 남은 호출 권한이 있나요?'",
            "통과하면 비즈니스 서버로 진입시킵니다."
        ],
        "rubric_functional": {
            "required_components": [
                "client",
                "api",
                "cache",
                "server"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "수많은 RESTful 인바운드 유입"
                },
                {
                    "from": "api",
                    "to": "cache",
                    "desc": "각 유저 세션 또는 식별 ID(IP) 기반 접근 토큰/버킷 남은 횟수 빠른 카운팅 감소 및 체크를 위한 Redis 조회 로직 선행"
                },
                {
                    "from": "api",
                    "to": "server",
                    "desc": "캐시의 Rate Limit 초과 시 에러 던짐, 제한 이내라면 온전하게 Server 비즈니스 라우팅 포워드"
                }
            ]
        },
        "axis_weights": {
            "방어기제 및 QoS 보장": "중요한 코어 서버의 무절제한 사용 남용을 중앙 병목 지점 없이 관리 방어"
        }
    },
    {
        "title": "대용량 동영상 트랜스코딩 작업열 설계",
        "description": "사용자가 백기가바이트급 4K 원본 동영상을 올리면, 서버가 죽지 않고 백그라운드에서 이를 모바일용, PC용 퀄리티로 수십 개의 조각(HLS 파싱)으로 각각 비동기로 나누어 인코딩하는 병렬 워커 레이어를 설계하세요.",
        "required": [
            "origin",
            "queue",
            "consumer",
            "readdb"
        ],
        "hints": [
            "업로드가 완료된 거대 영상(Origin)을 바탕으로 작업(Queue)이 배포됩니다.",
            "수십 개의 Worker(Consumer)가 영상을 10초 단위로 쪼개 무식하게 연산 후 메타데이터 정보 DB(readdb)에 기록합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "origin",
                "queue",
                "consumer",
                "readdb"
            ],
            "required_flows": [
                {
                    "from": "origin",
                    "to": "queue",
                    "desc": "클라우드 스토리지(S3 등) 거대 파일 적재 성공 콜백 이벤트 스니핑 발생 후 트리거 큐 삽입"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "FFmpeg 등의 강력한 CPU 연산 워커풀(Consumer) 대기자가 배치 작업 메시지 풀링 및 원본 다운로드 연산 개시"
                },
                {
                    "from": "consumer",
                    "to": "origin",
                    "desc": "연산결과(Ts 조각 인코딩 출력물)를 미디어 배포용 스토리지에 재저장(저장 재귀를 방지하는 맹목화 처리)"
                },
                {
                    "from": "consumer",
                    "to": "readdb",
                    "desc": "HLS m3u8 재생 리스트 메타데이터 주소와 서비스 정보 상태값을 읽기 저장소에 커밋"
                }
            ]
        },
        "axis_weights": {
            "배칭 병렬화": "무거운 CPU 렌더링 작업을 독립시킴으로써 메인 웹 스레드의 컨텍스트 스위칭 봉쇄"
        }
    },
    {
        "title": "SNS 뉴스피드 푸시 (Fan-Out on Write/Push Model)",
        "description": "수백만 명의 팔로워를 보유한 셀럽이 트윗(글)을 작성했을 때, 팔로워들의 피드를 접속(Pull) 전 미리 생성해서 인메모리(Cache)의 타임라인을 뿌려두고 DB에 삽입하는 쓰기 동기화 병목 구조를 우회성으로 설계하세요.",
        "required": [
            "writesvc",
            "queue",
            "consumer",
            "cache",
            "db"
        ],
        "hints": [
            "글 작성을 하는 writesvc",
            "대량 발송을 위한 Queue와 Consumer를 통한 백그라운드 분산처리",
            "팬들의 캐시(Cache - 피드 리스트)에 즉각 삽입 푸시"
        ],
        "rubric_functional": {
            "required_components": [
                "writesvc",
                "queue",
                "consumer",
                "cache",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "writesvc",
                    "desc": "트윗 및 스토리 작성(Mutation)"
                },
                {
                    "from": "writesvc",
                    "to": "db",
                    "desc": "원본 마스터 메타데이터 즉시 영속성 보장(Commit)"
                },
                {
                    "from": "writesvc",
                    "to": "queue",
                    "desc": "이벤트 생산 (특정 사용자 번호가 글 배포됨 알림 큐 발행)"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "구독된 Fan-Out Worker(Consumer)가 유저의 수백만 팔로워 목록을 GraphDB 등에서 조회함과 동시에 큐 데이터 풀오버"
                },
                {
                    "from": "consumer",
                    "to": "cache",
                    "desc": "수백, 수천만 명의 팔로워의 개인 타임라인(유저 ID를 키로 하는 Redis List)에 Post-ID를 Push 삽입 최적화 (Materialized Feed View)"
                }
            ]
        },
        "axis_weights": {
            "복잡도 조율 (Trade-off)": "Read 시점의 Database Join 연산과 Aggregate Overload 비용을, Write 시점의 Background 캐시 매핑 비용으로 100% 치환한 SNS 비즈니스의 정석적인 Read Heavy 보완 전략 (Push Feed 방식)"
        }
    },
    {
        "title": "MSA 오케스트레이션",
        "description": "서로 다른 세 가지 마이크로서비스를 통과하는 복잡한 작업을 수행해야하며, 만일 한 곳에서라도 실패가 발생할 경우 중앙 관리 컴포넌트(Orchestrator, 여기선 api 게이트웨이 또는 특정 orchestrator svc 역할 수행)가 보상 로직 명령을 다시 내리는 조율 기법을 나타내세요.",
        "required": [
            "api",
            "order",
            "payment",
            "auth",
            "db"
        ],
        "hints": [
            "API Gateway가 Orchestrator 역할을 맡는다고 임시 가정합니다.",
            "API에서 인증, 주문, 결제 등 여러 서비스를 지휘(Call) 및 결과반환을 취합합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "api",
                "order",
                "payment",
                "auth"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "api",
                    "desc": "복합 프로세스 (동기화된 워크플로) 진입 개시"
                },
                {
                    "from": "api",
                    "to": "auth",
                    "desc": "오케스트레이터 측에서 1번 플로우 (인증토큰 확인) 호출 수신"
                },
                {
                    "from": "api",
                    "to": "order",
                    "desc": "오케스트레이터 측에서 2번 플로우 (주문생성 및 로컬 DB상태 대기) 호출 진행"
                },
                {
                    "from": "api",
                    "to": "payment",
                    "desc": "오케스트레이터 측에서 3번 플로우 (결제승인/최종 성공) 호출. 실패 시 역순환(보상 API Call)하여 주문취소 재트리거 유도"
                }
            ]
        },
        "axis_weights": {
            "동기화/중앙 집중성": "Saga의 Choreography(메세지큐 기반 흩뿌림)와 달리 중앙(Orchestrator)에서 상태 머신(State Machine)을 가지고 각 서비스에 RESTful/gRPC 동기식 흐름 통제를 수행하는 가시성 및 결합 트레이드오프 파악능력"
        }
    },
    {
        "title": "단일 컴포넌트 고립 장애 예방 (Circuit Breaker 패러다임)",
        "description": "A 서비스가 B 서비스를 의존해 동기화/결제 응답을 요청하는 중 B 서비스 DB 단락 등의 이유로 응답대기 타임아웃 시간이 극도로 길어지고 있을 때, 게이트웨이가 즉시 Fail-fast 하거나 Fallback 캐시로 응답 차단을 하는 모식도를 설계하세요.",
        "required": [
            "api",
            "cache",
            "server",
            "payment"
        ],
        "hints": [
            "api(게이트웨이/서킷) -> payment(장애 컴포넌트) 호출을 시도하나 에러율 임계치 도달.",
            "이후 api -> cache를 통한 임시 응답 리턴 구조를 취합니다."
        ],
        "rubric_functional": {
            "required_components": [
                "api",
                "cache",
                "payment"
            ],
            "required_flows": [
                {
                    "from": "api",
                    "to": "payment",
                    "desc": "정상적인 상황. MSA 계층 간 RPC 동기화 요청을 수행하나, 수백 개의 쓰레드가 지연 블록 상태 돌입(TimeOut Error 누적 감지 상태 모의)"
                },
                {
                    "from": "api",
                    "to": "cache",
                    "desc": "차단벽(Circuit Open) 모드로 변환. 더 이상 지연 중인 payment 서비스로 트래픽을 넘기지 않고(Fail Fast), 이전 캐시 데이터나 기본값을 Fallback 처리하여 즉각 회복 탄력성(Resilience) 제공 응답 이룩"
                }
            ]
        },
        "axis_weights": {
            "탄력도(장애 격리능력)": "Cascade Failure (연쇄 폭발 지연 현상 장애 번짐) 차단 보호 시스템 메커니즘 구축 지식 평가"
        }
    },
    {
        "title": "데이터 분석 파이프라인 (Lamda/Kappa 아키텍처 관점)",
        "description": "실시간 스트리밍 분석(Speed Layer)과 장기간의 HDFS 배치 빅데이터 분석(Batch Layer)을 두 가지 소비 큐 시스템을 활용해 병렬로 저장하는 모습을 그리세요.",
        "required": [
            "producer",
            "queue",
            "consumer",
            "writesvc",
            "readdb"
        ],
        "hints": [
            "Producer -> Queue 형태로 거대 원본 데이터가 쌓이고",
            "큐에서 2군데의 Consumer 계열로 각각 나누어져 흐릅니다 (Speed 용, Batch 용)"
        ],
        "rubric_functional": {
            "required_components": [
                "producer",
                "queue",
                "consumer",
                "writesvc"
            ],
            "required_flows": [
                {
                    "from": "producer",
                    "to": "queue",
                    "desc": "변경 데이터 로깅(CDC / Change Data Capture) 이력 로그 원장 무한 스트리밍 삽입"
                },
                {
                    "from": "queue",
                    "to": "consumer",
                    "desc": "(1) 배치 레이어(Batch Layer): Spark/Hadoop Consumer 그룹이 주기를 두고 전체를 일괄 집계 (안전한 재처리용 스토리지 저장 목적)"
                },
                {
                    "from": "queue",
                    "to": "writesvc",
                    "desc": "(2) 스피드 레이어(Speed Layer, 여기서 Consumer 대체재로 모의 표현): Flink, Storm 등이 즉각적인 메모리 슬라이딩 윈도우 계산 후 초단위 갱신 결과 실시간 대시보드 리포팅을 위한 Writesvc 도달"
                }
            ]
        },
        "axis_weights": {
            "람다 아키텍처": "전통적인 배치 데이터 정제 정확성과, 실시간 스트림 지연시간 제로의 Trade-off를 분리 병합 운용하는 양방향 하이브리드 스트림 흐름 제어 능력 평가"
        }
    },
    {
        "title": "클라우드 네이티브 블루-그린(Blue-Green) 무중단 배포 스위칭",
        "description": "새로운 버전의 서버들을 띄우고 운영 중이지만 테스트가 끝나지 않아 아직 고객에게 노출시키지 않습니다. 배포 후 DNS나 로드밸런서가 신버전 서버들 쪽으로 가중치를 한번에 혹은 서서히 넘기는 구조 경로를 나타내세요.",
        "required": [
            "lb",
            "server",
            "writesvc",
            "db"
        ],
        "hints": [
            "로드밸런서가 구형 버전의 Server그룹과 신버전의 다른 Server 그룹(역할상 writesvc로 지칭할 수도 있음)을 앞두고 타겟그룹 라우팅 설정을 전환합니다.",
            "두 그룹은 모두 동일한 프로덕션 DB를 바라보고 있습니다."
        ],
        "rubric_functional": {
            "required_components": [
                "lb",
                "server",
                "writesvc",
                "db"
            ],
            "required_flows": [
                {
                    "from": "lb",
                    "to": "server",
                    "desc": "[Blue / v1.0] 현재 유저 서비스를 100% 감당 중인 구버전 애플리케이션 집합군 통신 상황"
                },
                {
                    "from": "lb",
                    "to": "writesvc",
                    "desc": "[Green / v2.0] 임의 배포된 신버전 애플리케이션 타겟 군으로 로드밸런서 계층에서 Weight 포워딩 ( Canary/Blue-Green 라우팅 전환 처리 가시화 )"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "구버전의 데이터 영속화 연결 상태 유지"
                },
                {
                    "from": "writesvc",
                    "to": "db",
                    "desc": "신버전 역시 동일한 호환성 스키마 무중단 환경(DB Migration 미시행 상태)에서 하위호환성 유지 공유 접근"
                }
            ]
        },
        "axis_weights": {
            "CICD 배포 무중단 안정도 확보": "엔드포인트 진입점의 라우팅 조작 레이어와, 백엔드 애플리케이션의 버저닝 그룹이 같은 Persistence Layer를 안전하게 공유하는가"
        }
    },
    {
        "title": "다계층 데이터 암호화 통로 (Zero Trust Network 토폴로지)",
        "description": "서버 내부망이라 하더라도 믿어선 안됩니다(Zero-Trust). 퍼블릭존(LB), 프라이빗망(Server), 격리 데이터망(DB) 간의 통신이 인증 프록시(WAF/Auth)를 통해 철저하게 검증되는 구조를 모사하세요.",
        "required": [
            "lb",
            "waf",
            "server",
            "auth",
            "db"
        ],
        "hints": [
            "LB -> Server 로 진입 시, 망 분리 벽을 한 단계 더 추가하여 바로 붙지 않거나 중간에 철저한 권한 및 WAF 경유를 상징적으로 두는 통신입니다."
        ],
        "rubric_functional": {
            "required_components": [
                "lb",
                "waf",
                "server",
                "auth",
                "db"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "lb",
                    "desc": "외부망 DMZ 존에 진입 (TLS Terminal SSL 적용)"
                },
                {
                    "from": "lb",
                    "to": "waf",
                    "desc": "네트워크 중간에 위치한 투명(Transparent) 인라인 검열 계층에서 페이로드 심층분석(DPI-Deep Packet Inspection) 및 방화벽 룰킷 적용"
                },
                {
                    "from": "waf",
                    "to": "auth",
                    "desc": "서버 통과 이전에 내부망 마이크로세그먼테이션(Identity Proxy) 환경에서의 mTLS 및 IAM 권한 확인"
                },
                {
                    "from": "auth",
                    "to": "server",
                    "desc": "모든 신원과 무결성이 증명된 서비스 간 전송 토큰을 가진 채 비로소 비즈니스 트랜잭션 도달"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "분리된 데이터 전용 프라이빗 격리 VPC 서브넷으로의 (단일 허용 포트) 접속 인가"
                }
            ]
        },
        "axis_weights": {
            "보안 아키텍처 완전성": "내부자 위협, Lateral Movement(측면 횡적 이동 해킹탈취) 방지를 위한 모든 컴포넌트 간 인증 세션 암호화 동선 시현력 증명"
        }
    },
    {
        "title": "비동기 주문 및 웹훅(Webhook) 통합 외부 발송 시스템",
        "description": "우리 서버의 주문 처리가 완료되면, 제3가(Third-Party 파트너사 - 예: 외부 택배사)의 외부 API 서버로 성공 상태 메타데이터를 통지해야합니다. 트랜잭션 지연을 막기위해 메세지큐 워커가 이를 책임지게 그리세요.",
        "required": [
            "client",
            "server",
            "db",
            "queue",
            "producer",
            "api"
        ],
        "hints": [
            "서버 -> 큐 -> 워커(Producer) -> 외부망(API/Origin)"
        ],
        "rubric_functional": {
            "required_components": [
                "server",
                "db",
                "queue",
                "producer",
                "api"
            ],
            "required_flows": [
                {
                    "from": "client",
                    "to": "server",
                    "desc": "기본 주문 처리 동기화 요청 (1초 내 응답 보장)"
                },
                {
                    "from": "server",
                    "to": "db",
                    "desc": "내부 상태 Local 트랜잭션 Commit"
                },
                {
                    "from": "server",
                    "to": "queue",
                    "desc": "완료 이벤트(Outbox Pattern 등) 메세지 브로커로 발송 삽입 후 클라이언트 응답"
                },
                {
                    "from": "queue",
                    "to": "producer",
                    "desc": "여기서 Producer 역할 아이콘을 웹훅 발송용 백그라운드 스케줄러/비동기 컨슈머 워커로 치환하여 데이터 획득"
                },
                {
                    "from": "producer",
                    "to": "api",
                    "desc": "알 수 없는 응답 패턴과 지연율을 가진 타 파트너사 서드파티 외부망(API Gateway Endpoint)에 Http Post 방식 비동기 통보 전송 수행 등 시퀄"
                }
            ]
        },
        "axis_weights": {
            "Fault Tolerance (실패 허용)": "파트너사 연동 시 그들의 장애(500 에러)가 아군 시스템의 블러킹(Blocking/Hang)현상을 창출하지 않도록 완벽히 고립화하는 통합 아키텍처(Integration Pattern) 평가"
        }
    }
]